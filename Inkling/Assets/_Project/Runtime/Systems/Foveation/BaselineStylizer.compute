// Baseline Stylizer Compute Shader
// Non-ML fallback for LOD0â†’LOD1 stylization using compute shader
// Self-contained implementation following InkTools patterns

#pragma kernel Stylize
#pragma kernel StylizeWatercolor
#pragma kernel StylizeCelShaded

// Input/Output textures
Texture2D<float4> _InputTexture;          // LOD0 simulation
RWTexture2D<float4> _OutputTexture;       // Stylized LOD1

// Style parameters
float _StyleIntensity;
float _EdgeThreshold;
float _ColorBleeding;
float _PaperInfluence;
float4 _ColorRamp[8];                     // Gradient for remapping
int _ColorRampLength;

// Dimensions
uint2 _TextureSize;
float2 _TexelSize;

// Sampling
SamplerState sampler_LinearClamp;

// Thread group size (8x8 optimal for mobile GPUs)
#define THREAD_GROUP_SIZE 8

// Helper functions
float3 RGB2HSV(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 HSV2RGB(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}

// Sobel edge detection
float SobelEdge(uint2 id)
{
    // 3x3 Sobel kernels
    float sobelX[9] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };
    float sobelY[9] = { 1, 2, 1, 0, 0, 0, -1, -2, -1 };

    float edgeX = 0;
    float edgeY = 0;

    [unroll]
    for (int y = -1; y <= 1; y++)
    {
        [unroll]
        for (int x = -1; x <= 1; x++)
        {
            int2 coord = int2(id) + int2(x, y);
            coord = clamp(coord, int2(0, 0), int2(_TextureSize) - 1);

            float luminance = dot(_InputTexture[coord].rgb, float3(0.299, 0.587, 0.114));
            int idx = (y + 1) * 3 + (x + 1);

            edgeX += luminance * sobelX[idx];
            edgeY += luminance * sobelY[idx];
        }
    }

    return length(float2(edgeX, edgeY));
}

// Box blur for color bleeding effect
float4 BoxBlur(uint2 id, int radius)
{
    float4 color = float4(0, 0, 0, 0);
    int samples = 0;

    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            int2 coord = int2(id) + int2(x, y);
            if (all(coord >= 0) && all(coord < int2(_TextureSize)))
            {
                color += _InputTexture[coord];
                samples++;
            }
        }
    }

    return samples > 0 ? color / float(samples) : _InputTexture[id];
}

// Main stylization kernel
[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void Stylize(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= _TextureSize))
        return;

    // Sample input
    float4 inputColor = _InputTexture[id.xy];

    // Edge detection
    float edge = SobelEdge(id.xy);
    edge = smoothstep(0.0, _EdgeThreshold, edge);

    // Color remapping using gradient
    float intensity = length(inputColor.rgb);
    int rampIndex = clamp(int(intensity * (_ColorRampLength - 1)), 0, _ColorRampLength - 1);
    float4 remappedColor = _ColorRamp[rampIndex];

    // Blend with edges
    float4 stylized = lerp(remappedColor, float4(0.1, 0.05, 0, 1), edge * 0.8);

    // Final blend with original
    float4 output = lerp(inputColor, stylized, _StyleIntensity);

    _OutputTexture[id.xy] = output;
}

// Watercolor stylization kernel
[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void StylizeWatercolor(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= _TextureSize))
        return;

    float4 inputColor = _InputTexture[id.xy];

    // Color bleeding via box blur
    float4 bleedColor = BoxBlur(id.xy, 2);
    float4 baseColor = lerp(inputColor, bleedColor, _ColorBleeding);

    // Edge darkening
    float edge = SobelEdge(id.xy);
    edge = smoothstep(0.0, _EdgeThreshold * 2.0, edge);

    // Enhance saturation for watercolor look
    float3 hsv = RGB2HSV(baseColor.rgb);
    hsv.y *= 1.2; // Increase saturation
    hsv.z *= 0.95; // Slightly darken
    baseColor.rgb = HSV2RGB(hsv);

    // Paper texture simulation (using noise)
    float paper = frac(sin(dot(float2(id.xy), float2(12.9898, 78.233))) * 43758.5453);
    paper = 0.8 + paper * 0.2;
    baseColor.rgb *= lerp(1.0, paper, _PaperInfluence);

    // Edge emphasis
    baseColor.rgb = lerp(baseColor.rgb, float3(0.05, 0.02, 0), edge);

    _OutputTexture[id.xy] = float4(baseColor.rgb, inputColor.a);
}

// Cel shading stylization kernel
[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void StylizeCelShaded(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= _TextureSize))
        return;

    float4 inputColor = _InputTexture[id.xy];

    // Quantize colors to create bands
    const int bands = 4;
    float3 quantized = floor(inputColor.rgb * bands + 0.5) / bands;

    // Strong edge detection for outlines
    float edge = SobelEdge(id.xy);
    edge = step(_EdgeThreshold, edge);

    // Apply black outlines
    float3 outlined = lerp(quantized, float3(0, 0, 0), edge);

    _OutputTexture[id.xy] = float4(outlined, inputColor.a);
}