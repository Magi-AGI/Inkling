// Fluid Simulation Compute Shader
// Implements Stable Fluids (Jos Stam) with vorticity confinement
// Designed for mobile-friendly performance

#pragma kernel Advection
#pragma kernel Diffusion
#pragma kernel Divergence
#pragma kernel Pressure
#pragma kernel SubtractGradient
#pragma kernel Vorticity
#pragma kernel VorticityConfinement
#pragma kernel AddForce
#pragma kernel AddDensity
#pragma kernel Clear

// Shared constants
int _Resolution;
float _DeltaTime;
float _Viscosity;
float _Vorticity;
float _Dissipation;
float _VelocityDissipation;
float4 _TexelSize; // (1/width, 1/height, width, height)

// Injection parameters
float4 _InjectionPoint; // xy: position, z: radius, w: unused
float4 _InjectionForce; // xy: force vector
float4 _InjectionColor; // rgba: color to inject

// Texture declarations
RWTexture2D<float2> _VelocityRead;
RWTexture2D<float2> _VelocityWrite;
RWTexture2D<float4> _DensityRead;
RWTexture2D<float4> _DensityWrite;
RWTexture2D<float4> _QuantityRead;
RWTexture2D<float4> _QuantityWrite;
RWTexture2D<float> _PressureRead;
RWTexture2D<float> _PressureWrite;
RWTexture2D<float> _DivergenceRead;
RWTexture2D<float> _DivergenceWrite;
RWTexture2D<float> _VorticityRead;
RWTexture2D<float> _VorticityWrite;

// Boundary condition handling
float2 SampleVelocityBoundary(int2 coord)
{
    coord = clamp(coord, 0, _Resolution - 1);
    float2 vel = _VelocityRead[coord];

    // Apply no-slip boundary conditions
    if (coord.x == 0 || coord.x == _Resolution - 1)
        vel.x = -vel.x;
    if (coord.y == 0 || coord.y == _Resolution - 1)
        vel.y = -vel.y;

    return vel;
}

float4 SampleQuantityBoundary(RWTexture2D<float4> tex, int2 coord)
{
    coord = clamp(coord, 0, _Resolution - 1);
    return tex[coord];
}

// Bilinear sampling for advection
float4 BilinearSample(RWTexture2D<float4> tex, float2 uv)
{
    float2 coord = uv * _Resolution - 0.5;
    int2 c0 = int2(floor(coord));
    int2 c1 = c0 + int2(1, 0);
    int2 c2 = c0 + int2(0, 1);
    int2 c3 = c0 + int2(1, 1);

    float2 f = frac(coord);

    float4 s0 = SampleQuantityBoundary(tex, c0);
    float4 s1 = SampleQuantityBoundary(tex, c1);
    float4 s2 = SampleQuantityBoundary(tex, c2);
    float4 s3 = SampleQuantityBoundary(tex, c3);

    return lerp(lerp(s0, s1, f.x), lerp(s2, s3, f.x), f.y);
}

float2 BilinearSampleVelocity(float2 uv)
{
    float2 coord = uv * _Resolution - 0.5;
    int2 c0 = int2(floor(coord));
    int2 c1 = c0 + int2(1, 0);
    int2 c2 = c0 + int2(0, 1);
    int2 c3 = c0 + int2(1, 1);

    float2 f = frac(coord);

    float2 s0 = SampleVelocityBoundary(c0);
    float2 s1 = SampleVelocityBoundary(c1);
    float2 s2 = SampleVelocityBoundary(c2);
    float2 s3 = SampleVelocityBoundary(c3);

    return lerp(lerp(s0, s1, f.x), lerp(s2, s3, f.x), f.y);
}

// Semi-Lagrangian advection
[numthreads(8, 8, 1)]
void Advection(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    float2 uv = (id.xy + 0.5) * _TexelSize.xy;

    // Trace backwards through velocity field
    float2 velocity = _VelocityRead[id.xy];
    float2 prevUV = uv - velocity * _DeltaTime * _TexelSize.xy;

    // Sample quantity at previous position
    float4 quantity = BilinearSample(_QuantityRead, prevUV);

    // Apply dissipation
    quantity *= _Dissipation;

    _QuantityWrite[id.xy] = quantity;
}

// Jacobi iteration for diffusion
[numthreads(8, 8, 1)]
void Diffusion(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    float alpha = (_TexelSize.x * _TexelSize.x) / (_Viscosity * _DeltaTime);
    float beta = 4.0 + alpha;

    float2 left = SampleVelocityBoundary(id.xy + int2(-1, 0));
    float2 right = SampleVelocityBoundary(id.xy + int2(1, 0));
    float2 bottom = SampleVelocityBoundary(id.xy + int2(0, -1));
    float2 top = SampleVelocityBoundary(id.xy + int2(0, 1));
    float2 center = _VelocityRead[id.xy];

    float2 result = (left + right + bottom + top + alpha * center) / beta;

    _VelocityWrite[id.xy] = result;
}

// Calculate divergence of velocity field
[numthreads(8, 8, 1)]
void Divergence(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    float2 left = SampleVelocityBoundary(id.xy + int2(-1, 0));
    float2 right = SampleVelocityBoundary(id.xy + int2(1, 0));
    float2 bottom = SampleVelocityBoundary(id.xy + int2(0, -1));
    float2 top = SampleVelocityBoundary(id.xy + int2(0, 1));

    float divergence = 0.5 * ((right.x - left.x) + (top.y - bottom.y));

    _DivergenceWrite[id.xy] = divergence;
}

// Jacobi iteration for pressure solve
[numthreads(8, 8, 1)]
void Pressure(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    int2 coord = id.xy;

    float left = coord.x > 0 ? _PressureRead[coord + int2(-1, 0)] : 0;
    float right = coord.x < _Resolution - 1 ? _PressureRead[coord + int2(1, 0)] : 0;
    float bottom = coord.y > 0 ? _PressureRead[coord + int2(0, -1)] : 0;
    float top = coord.y < _Resolution - 1 ? _PressureRead[coord + int2(0, 1)] : 0;

    float divergence = _DivergenceRead[coord];

    float pressure = (left + right + bottom + top - divergence) * 0.25;

    _PressureWrite[coord] = pressure;
}

// Subtract pressure gradient from velocity
[numthreads(8, 8, 1)]
void SubtractGradient(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    int2 coord = id.xy;

    float left = coord.x > 0 ? _PressureRead[coord + int2(-1, 0)] : _PressureRead[coord];
    float right = coord.x < _Resolution - 1 ? _PressureRead[coord + int2(1, 0)] : _PressureRead[coord];
    float bottom = coord.y > 0 ? _PressureRead[coord + int2(0, -1)] : _PressureRead[coord];
    float top = coord.y < _Resolution - 1 ? _PressureRead[coord + int2(0, 1)] : _PressureRead[coord];

    float2 gradient = 0.5 * float2(right - left, top - bottom);
    float2 velocity = _VelocityRead[coord];

    velocity -= gradient;

    _VelocityWrite[coord] = velocity;
}

// Calculate vorticity (curl of velocity field)
[numthreads(8, 8, 1)]
void Vorticity(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    float2 left = SampleVelocityBoundary(id.xy + int2(-1, 0));
    float2 right = SampleVelocityBoundary(id.xy + int2(1, 0));
    float2 bottom = SampleVelocityBoundary(id.xy + int2(0, -1));
    float2 top = SampleVelocityBoundary(id.xy + int2(0, 1));

    float vorticity = 0.5 * ((right.y - left.y) - (top.x - bottom.x));

    _VorticityWrite[id.xy] = vorticity;
}

// Apply vorticity confinement force
[numthreads(8, 8, 1)]
void VorticityConfinement(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    int2 coord = id.xy;

    float left = coord.x > 0 ? abs(_VorticityRead[coord + int2(-1, 0)]) : 0;
    float right = coord.x < _Resolution - 1 ? abs(_VorticityRead[coord + int2(1, 0)]) : 0;
    float bottom = coord.y > 0 ? abs(_VorticityRead[coord + int2(0, -1)]) : 0;
    float top = coord.y < _Resolution - 1 ? abs(_VorticityRead[coord + int2(0, 1)]) : 0;

    float2 gradientMag = 0.5 * float2(right - left, top - bottom);
    float length = length(gradientMag) + 0.0001;
    float2 N = gradientMag / length;

    float vorticity = _VorticityRead[coord];
    float2 force = _Vorticity * vorticity * float2(N.y, -N.x);

    float2 velocity = _VelocityRead[coord];
    velocity += force * _DeltaTime;

    _VelocityWrite[coord] = velocity;
}

// Add external force
[numthreads(8, 8, 1)]
void AddForce(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    float2 uv = (id.xy + 0.5) * _TexelSize.xy;
    float2 delta = uv - _InjectionPoint.xy;
    float dist = length(delta);

    if (dist < _InjectionPoint.z)
    {
        float falloff = 1.0 - (dist / _InjectionPoint.z);
        falloff = falloff * falloff;

        float2 velocity = _VelocityRead[id.xy];
        velocity += _InjectionForce.xy * falloff * _DeltaTime;
        _VelocityWrite[id.xy] = velocity;
    }
    else
    {
        _VelocityWrite[id.xy] = _VelocityRead[id.xy];
    }
}

// Add density/dye
[numthreads(8, 8, 1)]
void AddDensity(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    float2 uv = (id.xy + 0.5) * _TexelSize.xy;
    float2 delta = uv - _InjectionPoint.xy;
    float dist = length(delta);

    if (dist < _InjectionPoint.z)
    {
        float falloff = 1.0 - (dist / _InjectionPoint.z);
        falloff = falloff * falloff * falloff;

        float4 density = _DensityRead[id.xy];
        density = saturate(density + _InjectionColor * falloff);
        _DensityWrite[id.xy] = density;
    }
    else
    {
        _DensityWrite[id.xy] = _DensityRead[id.xy];
    }
}

// Clear buffers
[numthreads(8, 8, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    if (any(id.xy >= uint2(_Resolution, _Resolution)))
        return;

    _VelocityWrite[id.xy] = float2(0, 0);
    _DensityWrite[id.xy] = float4(0, 0, 0, 0);
    _PressureWrite[id.xy] = 0;
}